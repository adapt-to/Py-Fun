=================
科学计算库-NumPy
=================
 ————开源的数值编程工具

* 强大的N维数组对象：``ndarray``
* 对数组结构数据进行运算
* 随机数、线性代数、傅里叶变换等

.. note::
  ``numpy`` 提供了两种基本的对象：
  
  ``ndarray`` (N-dimensional array object)和 ``ufunc`` (universal function object)
   1. ``ndarray`` (下文统一称之为数组)是存储单一数据类型的多维数组
   2. ``ufunc`` 则是能够对数组进行处理的函数！

  高级工具 ``Pandas`` 也是基于 ``numpy`` 来构建的

NumPy介绍
=====================

    numpy构建的数组是一个多维的数组对象，由两部分构成：
    1. 实际的数据
    2. 描述这些数据的元数据

    >>> import numpy as np  # 导入numpy并命别名为np，这一般是约定俗称的
    >>> arr = np.array([[1,2,3,4,5],[0,3,2,5,2]])  #array()函数的括号内可以是 列表、元组、数组等可迭代对象
    >>> print(arr) # 输出中没有逗号
    [[1 2 3 4 5]
     [0 3 2 5 2]]
    >>> print(arr.ndim) # 求数组的维度的个数，线代中称为'秩',rank 
    2
    >>> print(arr.shape) # 求数组的具体维度（几行几列）返回的形式是tuple。如果返回的结果只有一个元素，那么就是一维数组
    (2, 5)
    >>> print(arr.size) # 数组中元素的总个数
    10
    >>> print(arr.dtype) # data-type:指数组中数值的类型。记住是数值的类型
    int32
    >>> print(arr.itemsize) # 数组中每个元素的字节大小。 int32在内存中占4个字节
    4
    >>> print(arr.data) # 实际包含数组元素的地址位置
    <memory at 0x000001EB63459120>
    >>>

    创建数组：array()函数的括号内可以是 列表、元组、数组可迭代对象等

    >>> import numpy as np
    >>> ar1 = np.array(range(5))  # 利用可迭代对象创建数组
    >>> print(ar1)
    [0 1 2 3 4]
    >>> ar2 = np.array([1, 2, 3.1, 4.5, 5.6])    #浮点型
    >>> print(ar2) # 注意看输出形式，输入中有float和int，结果全为float，这个叫向上统一
    [1.  2.  3.1 4.5 5.6] 
    >>> ar3 = np.array([[1,2,3],['a','b','c']])
    >>> print(ar3) # 向上合并，因为ar3中含有字符型，所以数值型也转换为字符型。因为数组中要求元素类型一致
    [['1' '2' '3']
     ['a' 'b' 'c']]
    >>> print(ar3.dtype)
    <U11  # 这里的 U11 就是unicode 表示字符型
    >>>
    
NumPy的索引及切片
======================
 
一维数组的索引及切片
-----------------------

    >>> import numpy as np # 导入模块
    >>> 
    >>> ar = np.arange(20) # 利用numpy的arange()方法生成一个含有20个元素的一维数组
    >>> print(type(ar)) # 查看类型
    <class 'numpy.ndarray'>
    >>> print(ar)
    [ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19] # 注意没有逗号
    >>> print(ar[4]) # 元素索引，和python的序列索引类似
    4
    >>> print(ar[5:8]) # 切片，也和python的序列切片类似
    [5 6 7]
    >>> print(ar[:5])
    [0 1 2 3 4]
    >>> print(ar[:9])
    [0 1 2 3 4 5 6 7 8]
    >>> print(ar[::2])  # 指定步长
    [ 0  2  4  6  8 10 12 14 16 18]
    >>>

二维数组的索引及切片
-----------------------

    >>> import numpy as np # 导入模块
    >>> ar = np.arange(20).reshape(4,5) # 通过reshape()指定数组的维度
    >>> print(ar) # 输出为4行5列的二维数组
    [[ 0  1  2  3  4]
     [ 5  6  7  8  9]
     [10 11 12 13 14]
     [15 16 17 18 19]]
    >>> print(ar.ndim) # 输出数组ar的轴数
    2  # 因为是二维，所以轴数为2
    >>> print(ar[0][4]) # 索引到第0行第4个元素（从0开始计数）
    4
    >>> print(ar[0])  # 拿出第一行
    [0 1 2 3 4] # 这是第一行的数据
    >>> print(ar[0].ndim)
    1  # 因为第一行是一维数组，所以轴数为1
    >>> print(ar[1:3]) # 二维数组切片，结果为由第1行和第2行组成的新的二维数组（从0开始计数）
    [[ 5  6  7  8  9]
     [10 11 12 13 14]]
    >>> print(ar[0::2]) # 二维数组切片也可以指定步长，输出为第0行开始步长为2，组成的一个多维数组
    [[ 0  1  2  3  4]
     [10 11 12 13 14]]
    >>>

 .. note::
  * 二维数组的索引依然为一个元素，只不过需要 **二次** 索引，即先索引某行再索引某列，最后锁定到一个元素。
  * 二维数组的切片可能为一维数组也可能为一个二维数组，取决于切片的长度。

三维数组的索引及切片
---------------------------

    >>> import numpy as np # 导入模块
    >>> ar = np.arange(27).reshape(3,3,3) # 3*3*3 = 27
    >>> print(ar) # 这是一个三维数组
    [[[ 0  1  2]
      [ 3  4  5]
      [ 6  7  8]]
     [[ 9 10 11]
      [12 13 14]
      [15 16 17]]
     [[18 19 20]
      [21 22 23]
      [24 25 26]]]
    >>> print(ar[0][0][1]) # 三维数组索引，需要三次索引
    1
    >>> print(ar.ndim) # 三维数组所以轴数为3
    3
    >>> print(ar[0], ar[0].ndim) # ar[0]为二维数组，故轴数为2
    [[0 1 2]
     [3 4 5]
     [6 7 8]] 2
    >>> print(ar[0][1], ar[0][1].ndim) # ar[0][1]为一维数组，轴数为1
    [3 4 5] 1
    >>>
 .. note::
  * 三维数组的索引依然为一个元素，只不过需要 **三次** 索引，索引一次结果为二维数组，再索引一次结果为一维数组，最后索引一次锁定到某个元素。
  * 三维数组的切片可能为一维数组、二维数组、三维数组中的某一个，取决于切片的长度。
  * 如果一次切片长度为1，则结果为一个二维数组，一次切片长度大于1，则结果为一个三维数组
  * 要想获得一维数组，则需要对三维数组进行二次切片，即先切片一次获得一个二维数组，再对二维数组切片获得一维数组 

布尔型的索引和切片
--------------------

    >>> import numpy as np
    >>> ar = np.arange(12).reshape(3,4)
    >>> i = np.array([True, False, True])
    >>> j = np.array([True, False, True, False])
    >>> print(ar) # 输出数组ar
    [[ 0  1  2  3]
     [ 4  5  6  7]
     [ 8  9 10 11]]
    >>> print(ar[i,:]) # 在第一维度做判断，只保留True对应的数据。这里的第一维度是行。
    [[ 0  1  2  3]
     [ 8  9 10 11]]
    >>> print(ar[:, j]) # 在第二维度做判断，与上同理，这里的第二维度是列
    [[ 0  2]
     [ 4  6]
     [ 8 10]]
    >>> m = ar > 5 # 输出为布尔型矩阵
    >>> print(m)
    [[False False False False]
     [False False  True  True]
     [True  True  True  True]]
    >>> print(ar[m]) # 用m判断矩阵去筛选ar数组中的>5的元素
    [ 6  7  8  9 10 11]
    >>>


NumPy-指定区间内等分数据
=========================
 
    >>> import numpy as np
    >>> a = np.linspace(1,10,5) # 该方法前2个数指定首位和尾部数字，第三个指定将这部分等分为多少段
    >>> 
    >>> print(a) 
    [ 1.    3.25  5.5   7.75 10.  ]
    >>> print(type(a[0])) # 返回的数值默认为float64
    <class 'numpy.float64'>
    >>> b = np.linspace(1,10,6).reshape((2,3)) # 配合reshape方法
    >>> print(b)
    [[ 1.   2.8  4.6]
     [ 6.4  8.2 10. ]]
    >>> print(b.dtype)
    float64
    >>>


NumPy中的浅拷贝和深拷贝
=========================
 
  NumPy中如果利用切片的原理进行拷贝，则拷贝后的数据和原数据是共用一套数据，它们之间数据共享，即为浅拷贝。

    >>> import numpy as np
    >>> ar = np.array(range(5))
    >>> br = ar[:] # 拷贝数据给对象br，这里其实也是切片，只不过是切片了整个ar给br
    >>> print(ar, br)
    [0 1 2 3 4] [0 1 2 3 4]
    >>> print(id(ar),id(br)) # 你会发现它们的id是不一样的，但是它们的数据是共享的
    140088680084224 140088680084384
    >>> ar[1] = 100
    >>> print(ar, br) # 所以只修改ar中的值，br也会跟着修改
    [  0 100   2   3   4] [  0 100   2   3   4]
    >>>

 如果不想出现上述的现象，那么就用深拷贝，在 ``numpy`` 中深拷贝是利用 ``array`` 对象中的 ``copy()`` 方法实现的。
 这在 ``python`` 中的深浅拷贝有所不同，这里的 ``copy()`` 就等同于 ``python`` 中深拷贝 ``deepcopy()``

    >>> ar = np.array(range(5))
    >>> br = ar.copy() # 这里用深拷贝，br对象和ar对象除了数值相等之外 无任何关系
    >>> print(ar, br)
    [0 1 2 3 4] [0 1 2 3 4]
    >>> print(id(ar),id(br)) # id值依然不相等
    140088680084784 140088680084944
    >>> ar[1] = 100
    >>> print(ar, br) # 修改ar的值不影响br，同理修改br也不会影响ar的值
    [  0 100   2   3   4] [0 1 2 3 4]
    >>>

NumPy中随机数
=========================
 ——由于 ``numpy.random`` 包含多种概率分布的随机样本，故其是数据分析辅助的重点工具之一

    >>> import numpy as np # 导入模块
    >>> 
    >>> rand_number = np.random.normal(size=(3,3)) # 利用normal()方法生成一个标准正太分布的3*3样本值
    >>> print(rand_number)
    [[-0.82594205  0.50800583  0.39472314]
     [-0.56514795  0.82111505 -0.22010978]
     [ 0.50343797  1.1543087   0.21979859]]
    >>> rand_number = np.random.normal(size=(5)) # size指定它的shape
    >>> print(rand_number) 3 输出为一维数组
    [-0.43982788  0.81971666  0.71810232 -0.93671977 -0.12508982]
    >>>

生成[0,1)之间的随机浮点数(数组)
---------------------------------------
  —— 利用 ``numpy.random.rand()`` 方法，结果满足 **均匀分布**
 
    >>> import numpy as np # 导入模块
    >>> rand = np.random.rand() # 括号不添加参数，则输出为1个数
    >>> print(rand, type(rand))
    0.8750019466316016 <class 'float'>
    >>> rand_1 = np.random.rand(4) # 参数为4，则输出4个在[0,1)区间的随机数构成的一维数组
    >>> print(rand_1, type(rand_1))
    [0.23196631 0.37355104 0.43773787 0.81470703] <class 'numpy.ndarray'>
    >>> rand_2 = np.random.rand(3,3) # 输出 3*3 的二维数组
    >>> print(rand_2)
    [[0.3232683  0.29482801 0.40134497]
     [0.36757934 0.20004137 0.4931598 ]
     [0.32954516 0.30837629 0.21156013]]
    >>> 

 .. note::
    ``rand()`` 方法，根据括号中的参数不同，输出为对应的数组。例如: ``rand = np.random.rand(1000)`` ，
    就是生成1000个满足均匀分布的样本值，这在计算概率或其他方面有重要意义。

 